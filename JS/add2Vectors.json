"var argsFromMain=null;\nfunction init(prms) {argsFromMain=prms;}\n//init();\n//if (argsFromMain == null) {argsFromMain=[[300, 1400], [[2, 0], [0, 3]]];}\n//if (argsFromMain == null) {argsFromMain=[[20, 20], [[2, 0], [0, 3]], 'off'];}\nif (argsFromMain == null) {argsFromMain=[[20, 20], [[2, 0, -2,-1], [0, 3, 1, 3]], 'off'];}\n//[cnvs.height, cnvs.width]=argsFromMain[0];\n//cnvs.width=window.innerWidth-50; cnvs.height=window.innerHeight-380;\nconst rA = argsFromMain[0][0], jB=argsFromMain[0][1];\nvar pxX, pxY, bbox, dragging=false, vec2drag=null, point=null;\n\nconst hafA=rA/2, yo=20.5, yB=yo+jB*rA, jC=jB/2, cY=yo+rA*jC, hafPI=Math.PI/2;\ncnvs.height = yB+10, cnvs.width = yB+220;\nconst ch=cnvs.height, cw=cnvs.width;\nconst btn=argsFromMain[2];\nvar SubmitBtn=null;\n\nif (btn == 'on') {SubmitBtn={x: yB+100, y:40, w:140, h:50, color:\"#d7d\"};}\n\nfunction randInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nconst colors={0:\"red\", 1:\"green\", 2:\"blue\", 3:\"#ff0\", 4: \"#f0f\", 5:\"#0ff\"};\nconst vectors = new Array();\nfor (let j=0; j<argsFromMain[1].length; j++) {\n  const vec = argsFromMain[1][j];\n  if (vec.length == 2) {vectors.push({x: vec[0]*rA, y: vec[1]*rA, xo: randInt(-3,4)*rA, yo: randInt(-3,4)*rA, c: colors[j], points: null});}\n  else {vectors.push({x: vec[0]*rA, y: vec[1]*rA, xo: vec[2]*rA, yo: vec[3]*rA, c: colors[j], points: null});}\n}\n\nfor (let j=0; j<vectors.length; j++) {\n  var points=[], ratio, xVo=vectors[j].xo+cY, yVo=cY-vectors[j].yo;\n\n  if (Math.abs(vectors[j].x) > Math.abs(vectors[j].y)) {\n    ratio = vectors[j].y/vectors[j].x;\n    if (vectors[j].x > 0) {\n      for (let x=0; x<=vectors[j].x; x++) {points.push([xVo+x, yVo+x*ratio]);}\n    }\n    else {\n      for (let x=0; x>=vectors[j].x; x--) {points.push([xVo+x, yVo+x*ratio]);}\n    }\n    points.push('x');\n  }\n  else {\n    ratio = vectors[j].x/vectors[j].y;\n    if (vectors[j].y > 0) {\n      for (let y=0; y<=vectors[j].y; y++) {points.push([xVo+y*ratio, yVo-y]);}\n    }\n    else {\n      for (let y=0; y>=vectors[j].y; y--) {points.push([xVo+y*ratio, yVo-y]);}\n    }\n    points.push('y');\n  }\n  vectors[j].points=points;\n}\n\n//console.log(vectors);\nvar y, angle, length, canvasImage;\n\nfunction drawBackground() {\n  ctx.fillStyle=\"black\"; ctx.font = \"12px Arial\";  ctx.textAlign=\"center\";\n  for (j=0; j<=jB; j++) {\n    y = yo+j*rA;\n    if ((j-jC)%5 == 0) {\n      ctx.beginPath();\n      ctx.strokeStyle=\"#aaa\";\n      ctx.fillText(Math.floor((j-jC)/5)*5, y, cY+13);\n      ctx.fillText(Math.floor((jC-j)/5)*5, cY-10, y+5);\n    }\n    else {ctx.strokeStyle=\"#ddd\";}\n    ctx.beginPath(); ctx.moveTo(y, yo); ctx.lineTo(y, yB); ctx.stroke(); // vertical;\n    ctx.beginPath(); ctx.moveTo(yo, y); ctx.lineTo(yB, y); ctx.stroke(); //horizontal;\n  }\n\n  if (SubmitBtn != null) {\n    ctx.beginPath();\n    ctx.shadowColor = \"black\";\n    ctx.shadowOffsetX = 1;\n    ctx.shadowOffsetY = 1;\n    ctx.shadowBlur = 3;\n    ctx.fillStyle=SubmitBtn.color;\n    ctx.fillRect(SubmitBtn.x-SubmitBtn.w/2,SubmitBtn.y-SubmitBtn.h/2,SubmitBtn.w,SubmitBtn.h);\n    ctx.shadowColor = \"transparent\";\n    ctx.fillStyle=\"black\"; ctx.font = \"28px arial\"; ctx.textAlign=\"center\"; \n    ctx.fillText(\"Submit\", SubmitBtn.x, SubmitBtn.y+10);\n    ctx.closePath();\n  }\n  canvasImage=ctx.getImageData(0,0,cw,ch);\n}\n\ndrawBackground();\n\nfunction Submit() {\n  var ans=\"to be determined....\";\n  answers[Qnumber]=ans;\n  addAnswers2Textarea();\n}\n\n\n\nfunction isPointOnLine(points, x,y) {\n  const xORy = points.slice(-1);\n  if (xORy == 'x') {\n    for (let j=0; j<points.length-1; j++) {\n      if (points[j][0] == x) {\n         if (points[j][1]-1 <= y && y <= points[j][1]+1) {\n            return true;\n         }\n      }\n    }\n  }\n  else {\n    for (let j=0; j<points.length-1; j++) {\n      if (points[j][1] == y) {\n         if (points[j][0]-1 <= x && x <= points[j][0]+1) {\n            return true;\n         }\n      }\n    }\n  }\n  return false;\n}\n\nfunction onmouseup(e) {\n  if (dragging) {\n    const dx=vectors[vec2drag].xo+cY-vectors[vec2drag].points[0][0], dy=cY-vectors[vec2drag].yo-vectors[vec2drag].points[0][1];\n\n    var newPoints = new Array();\n    for (let j=0; j<vectors[vec2drag].points.length-1; j++) {\n      newPoints.push( [vectors[vec2drag].points[j][0]+dx, vectors[vec2drag].points[j][1]+dy]);\n    }\n    newPoints.push(vectors[vec2drag].points.slice(-1));\n\n    vectors[vec2drag].points=newPoints;\n    vectors[vec2drag].c = vec2drag ? \"blue\" : \"red\";\n    dragging=false;\n    vec2drag=null;\n    point = null;\n    drawAll();\n  }\n}\n\nfunction onmousedown(e) {\n  e.preventDefault();\n  bbox = cnvs.getBoundingClientRect();\n  pxX=e.clientX-bbox.left*(cw/bbox.width);\n  pxY=e.clientY-bbox.top*(ch/bbox.height);\n\n  if (SubmitBtn != null && SubmitBtn.x-SubmitBtn.w/2<=pxX && pxX <= SubmitBtn.x+SubmitBtn.w/2 && SubmitBtn.y-SubmitBtn.h/2<=pxY && pxY <= SubmitBtn.y+SubmitBtn.h/2) {Submit();}\n\n\n  for (let j=0; j<vectors.length; j++) {\n    const isItON = isPointOnLine(vectors[j].points, Math.round(pxX)+0.5, Math.round(pxY)+0.5);\n    if (isItON) {\n       dragging=true;\n       vec2drag=j;\n       vectors[j].c=\"black\";\n       point = [Math.round(pxX)+0.5, Math.round(pxY)+0.5];\n       drawAll();\n       break;\n    }\n  }\n}\n\n\nfunction onmousemove(e) {\n  e.preventDefault();\n  bbox = cnvs.getBoundingClientRect();\n  pxX=e.clientX-bbox.left*(cw/bbox.width);\n  pxY=e.clientY-bbox.top*(ch/bbox.height);\n\n  if (dragging) {\n    vectors[vec2drag].xo += (Math.round(pxX)+0.5-point[0]);\n    vectors[vec2drag].yo += -(Math.round(pxY)+0.5-point[1]);\n    point = [Math.round(pxX)+0.5, Math.round(pxY)+0.5];\n    drawAll();\n  }\n  else {\n    for (let j=0; j<vectors.length; j++) {\n      const isItON = isPointOnLine(vectors[j].points, Math.round(pxX)+0.5, Math.round(pxY)+0.5);\n      if (isItON) {\n        vectors[j].c=\"black\";\n        drawAll();\n        break;\n      }\n      else {\n        vectors[j].c=colors[j];\n        drawAll();\n      }\n    }\n  }\n}\n\n\n\nfunction drawVector(angle, length) {\n  ctx.beginPath(); ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n}\n\nfunction drawAll() {\n  ctx.putImageData(canvasImage,0,0);\n/*\n  if (vectors[0].xo-0.1 <= vectors[1].xo && vectors[1].xo <= vectors[0].xo+0.1 && vectors[0].yo-0.1 <= vectors[1].yo && vectors[1].yo <= vectors[0].yo+0.1) {\n    vectors[vec2drag].c = vec2drag ? \"blue\" : \"red\";\n    vec2drag=null;\n    point = null;\n    dragging=false;\n    vectors[0].xo=0, vectors[0].yo=0, vectors[1].xo=0, vectors[1].yo=0;\n  }\n*/\n\n  ctx.lineWidth=2;\n  for (let j=0; j<vectors.length; j++) {\n    ctx.beginPath();\n    ctx.translate(vectors[j].xo+cY, cY-vectors[j].yo);\n    ctx.strokeStyle=vectors[j].c;\n    angle=hafPI-Math.atan2(vectors[j].y, vectors[j].x);\n    length=Math.sqrt(vectors[j].x**2 + vectors[j].y**2);\n    ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n    ctx.translate(-vectors[j].xo-cY, vectors[j].yo-cY);\n  }\n  ctx.lineWidth=1;\n\n}\n\ncnvs.addEventListener('mouseup', onmouseup);\ncnvs.addEventListener('mousedown', onmousedown);\ncnvs.addEventListener('mousemove', onmousemove);\n\ndrawAll();"