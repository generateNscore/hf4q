"var argsFromMain=null;\nfunction init(prms) {argsFromMain=prms;}\n//init();\n//if (argsFromMain == null) {argsFromMain=[[300, 1400], [[2, 0], [0, 3]]];}\nif (argsFromMain == null) {argsFromMain=[[20, 20], [[2, 0, -2,-1], [0, 3, 1, 3]], 'off'];}\n//[cnvs.height, cnvs.width]=argsFromMain[0];\n//cnvs.width=window.innerWidth-50; cnvs.height=window.innerHeight-380;\nconst rA = argsFromMain[0][0], jB=argsFromMain[0][1];\nvar pxX, pxY, bbox, dragging=false, vec2drag=null, point=null;\n\nconst hafA=rA/2, yo=20.5, yB=yo+jB*rA, jC=jB/2, cY=yo+rA*jC, hafPI=Math.PI/2;\ncnvs.height = yB+10, cnvs.width = yB+20;\nconst ch=cnvs.height, cw=cnvs.width;\nconst btn=argsFromMain[2];\nvar SubmitBtn=null;\n\nif (btn == 'on') {SubmitBtn={x: yB+100, y:40, w:140, h:50, color:\"#d7d\"};}\n\nfunction randInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nfunction v2pxl(v, xORy) {\n  if (xORy == 'y') {return cY-rA*v;}\n  else {return cY+rA*v;}\n}\n\nconst colors={0:\"red\", 1:\"green\", 2:\"blue\", 3:\"#ff0\", 4: \"#f0f\", 5:\"#0ff\"};\n\nvar vectors;\nif (typeof answers[Qnumber] ===\"object\" && answers[Qnumber] != null && answers[Qnumber].hasOwnProperty(\"figure\") && answers[Qnumber].hasOwnProperty(\"prm\")) {\n  vectors=answers[Qnumber].prm;\n}\nelse {\n  vectors = [];\n  for (let j=0; j<argsFromMain[1].length; j++) {\n    const vec = [randInt(-6,7), randInt(-6,7), randInt(-3,4), randInt(-3,4)];\n\n    if (vec.length == 2) {vectors.push({x: vec[0], y: vec[1], xo: randInt(-3,4), yo: randInt(-3,4), c: colors[j], points: null});}\n    else {vectors.push({x: vec[0], y: vec[1], xo: vec[2], yo: vec[3], c: colors[j], points: null});}\n  }\n}\n\nfor (let j=0; j<vectors.length; j++) {\n  var points=[], ratio, xVo=v2pxl(vectors[j].xo, 'x'), yVo=v2pxl(vectors[j].yo,'y');\n\n  if (Math.abs(vectors[j].x) > Math.abs(vectors[j].y)) {\n    ratio = vectors[j].y/vectors[j].x;\n    if (vectors[j].x > 0) {\n      for (let x=xVo; x<=v2pxl(vectors[j].x+vectors[j].xo, 'x'); x++) {points.push([x, yVo-(x-xVo)*ratio]);}\n    }\n    else {\n      for (let x=xVo; x>=v2pxl(vectors[j].x+vectors[j].xo, 'x'); x--) {points.push([x, yVo-(x-xVo)*ratio]);}\n    }\n    points.push('x');\n  }\n  else {\n    ratio = vectors[j].x/vectors[j].y;\n    if (vectors[j].y < 0) {\n      for (let y=yVo; y<=v2pxl(vectors[j].y+vectors[j].yo,'y'); y++) {points.push([xVo+(yVo-y)*ratio, y]);}\n    }\n    else {\n      for (let y=yVo; y>=v2pxl(vectors[j].y+vectors[j].yo,'y'); y--) {points.push([xVo+(yVo-y)*ratio, y]);}\n    }\n    points.push('y');\n  }\n  vectors[j].points=points;\n}\n\n//console.log(vectors);\nvar y, angle, length, canvasImage;\n\nfunction drawBackground() {\n  ctx.fillStyle=\"black\"; ctx.font = \"12px Arial\";  ctx.textAlign=\"center\";\n  for (j=0; j<=jB; j++) {\n    y = yo+j*rA;\n    if ((j-jC)%5 == 0) {\n      ctx.beginPath();\n      ctx.strokeStyle=\"#aaa\";\n      ctx.fillText(Math.floor((j-jC)/5)*5, y, cY+13);\n      ctx.fillText(Math.floor((jC-j)/5)*5, cY-10, y+5);\n    }\n    else {ctx.strokeStyle=\"#ddd\";}\n    ctx.beginPath(); ctx.moveTo(y, yo); ctx.lineTo(y, yB); ctx.stroke(); // vertical;\n    ctx.beginPath(); ctx.moveTo(yo, y); ctx.lineTo(yB, y); ctx.stroke(); //horizontal;\n  }\n\n  if (SubmitBtn != null) {\n    ctx.beginPath();\n    ctx.shadowColor = \"black\";\n    ctx.shadowOffsetX = 1;\n    ctx.shadowOffsetY = 1;\n    ctx.shadowBlur = 3;\n    ctx.fillStyle=SubmitBtn.color;\n    ctx.fillRect(SubmitBtn.x-SubmitBtn.w/2,SubmitBtn.y-SubmitBtn.h/2,SubmitBtn.w,SubmitBtn.h);\n    ctx.shadowColor = \"transparent\";\n    ctx.fillStyle=\"black\"; ctx.font = \"28px arial\"; ctx.textAlign=\"center\"; \n    ctx.fillText(\"Submit\", SubmitBtn.x, SubmitBtn.y+10);\n    ctx.closePath();\n  }\n  canvasImage=ctx.getImageData(0,0,cw,ch);\n}\n\ndrawBackground();\n\nfunction Submit() {\n  var ans=\"to be determined....\";\n  answers[Qnumber]=ans;\n  addAnswers2Textarea();\n}\n\n\n\nfunction isPointOnLine(points, x,y) {\n  //const xORy = ;\n  if (points.slice(-1) == 'x') {\n    for (let j=0; j<points.length-1; j++) {\n      if (points[j][0] == x) {\n         if (points[j][1]-1 <= y && y <= points[j][1]+1) {\n            return true;\n         }\n      }\n    }\n  }\n  else {\n    for (let j=0; j<points.length-1; j++) {\n      if (points[j][1] == y) {\n         if (points[j][0]-1 <= x && x <= points[j][0]+1) {\n            return true;\n         }\n      }\n    }\n  }\n  return false;\n}\n\nfunction onmouseup(e) {\n  vectors[vec2drag].c = colors[vec2drag];\n  dragging=false;\n  vec2drag=null;\n  point = null;\n  drawAll();\n}\n\nfunction onmousedown(e) {\n  e.preventDefault();\n  bbox = cnvs.getBoundingClientRect();\n  pxX=e.clientX-bbox.left*(cw/bbox.width);\n  pxY=e.clientY-bbox.top*(ch/bbox.height);\n\n  if (SubmitBtn != null && SubmitBtn.x-SubmitBtn.w/2<=pxX && pxX <= SubmitBtn.x+SubmitBtn.w/2 && SubmitBtn.y-SubmitBtn.h/2<=pxY && pxY <= SubmitBtn.y+SubmitBtn.h/2) {Submit();}\n\n\n  for (let j=0; j<vectors.length; j++) {\n    const isItON = isPointOnLine(vectors[j].points, Math.round(pxX)+0.5, Math.round(pxY)+0.5);\n    if (isItON) {\n       dragging=true;\n       vec2drag=j;\n       vectors[j].c=\"black\";\n       point = [Math.round(pxX)+0.5, Math.round(pxY)+0.5];\n       drawAll();\n       break;\n    }\n  }\n}\n\n\nfunction onmousemove(e) {\n  e.preventDefault();\n  bbox = cnvs.getBoundingClientRect();\n  pxX=e.clientX-bbox.left*(cw/bbox.width);\n  pxY=e.clientY-bbox.top*(ch/bbox.height);\n\n  if (dragging) {\n    const dx=(Math.round(pxX)+0.5-point[0]);\n    const dy=(Math.round(pxY)+0.5-point[1]);\n    vectors[vec2drag].xo += dx/rA;\n    vectors[vec2drag].yo -= dy/rA;\n    for (let j=0; j<vectors[vec2drag].points.length; j++) {\n       vectors[vec2drag].points[j][0] += dx;\n       vectors[vec2drag].points[j][1] += dy;\n    }\n    point = [Math.round(pxX)+0.5, Math.round(pxY)+0.5];\n    drawAll();\n  }\n  else {\n    for (let j=0; j<vectors.length; j++) {\n      const isItON = isPointOnLine(vectors[j].points, Math.round(pxX)+0.5, Math.round(pxY)+0.5);\n      if (isItON) {\n        vectors[j].c=\"black\";\n        drawAll();\n        break;\n      }\n      else {\n        vectors[j].c=colors[j];\n        drawAll();\n      }\n    }\n  }\n}\n\n\n\nfunction drawVector(angle, length) {\n  ctx.beginPath(); ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n}\n\nfunction drawAll() {\n  ctx.putImageData(canvasImage,0,0);\n\n  ctx.lineWidth=2;\n  for (let j=0; j<vectors.length; j++) {\n    ctx.beginPath();\n    ctx.translate(v2pxl(vectors[j].xo, 'x'), v2pxl(vectors[j].yo,'y'));\n    ctx.strokeStyle=vectors[j].c;\n    //angle=hafPI-Math.atan2(vectors[j].y, vectors[j].x);\n    //angle=Math.atan2(vectors[j].y, vectors[j].x);\n    angle=Math.atan2(vectors[j].x, vectors[j].y);\n    length=rA*Math.sqrt(vectors[j].x**2 + vectors[j].y**2);\n    ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n    ctx.translate(-v2pxl(vectors[j].xo, 'x'), -v2pxl(vectors[j].yo,'y'));\n\n  }\n  ctx.lineWidth=1;\n\n\n  if (vectors[0].xo-0.1 <= vectors[1].xo && vectors[1].xo <= vectors[0].xo+0.1 && vectors[0].yo-0.1 <= vectors[1].yo && vectors[1].yo <= vectors[0].yo+0.1) {\n    const sumVec = {x: vectors[0].x+vectors[1].x, y: vectors[0].y+vectors[1].y, xo: vectors[0].xo, yo: vectors[0].yo};\n    console.log(sumVec);\n    ctx.beginPath();\n    ctx.translate(v2pxl(sumVec.xo, 'x'), v2pxl(sumVec.yo,'y'));\n    ctx.strokeStyle=\"black\";\n    angle=Math.atan2(sumVec.x, sumVec.y);\n    length=rA*Math.sqrt(sumVec.x**2 + sumVec.y**2);\n    ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n    ctx.translate(-v2pxl(sumVec.xo, 'x'), -v2pxl(sumVec.yo,'y'));\n  }\n\n  if (vectors[0].xo-0.1 <= vectors[1].xo+vectors[1].x && vectors[1].xo+vectors[1].x <= vectors[0].xo+0.1 && vectors[0].yo-0.1 <= vectors[1].yo+vectors[1].y && vectors[1].yo+vectors[1].y <= vectors[0].yo+0.1) {\n\n    const sumVec = {x: vectors[0].x+vectors[1].x, y: vectors[0].y+vectors[1].y, xo: vectors[1].xo, yo: vectors[1].yo};\n    console.log(sumVec);\n    ctx.beginPath();\n    ctx.translate(v2pxl(sumVec.xo, 'x'), v2pxl(sumVec.yo,'y'));\n    ctx.strokeStyle=\"black\";\n    angle=Math.atan2(sumVec.x, sumVec.y);\n    length=rA*Math.sqrt(sumVec.x**2 + sumVec.y**2);\n    ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n    ctx.translate(-v2pxl(sumVec.xo, 'x'), -v2pxl(sumVec.yo,'y'));\n  }\n\n  if (vectors[1].xo-0.1 <= vectors[0].xo+vectors[0].x && vectors[0].xo+vectors[0].x <= vectors[1].xo+0.1 && vectors[1].yo-0.1 <= vectors[0].yo+vectors[0].y && vectors[0].yo+vectors[0].y <= vectors[1].yo+0.1) {\n\n    const sumVec = {x: vectors[0].x+vectors[1].x, y: vectors[0].y+vectors[1].y, xo: vectors[0].xo, yo: vectors[0].yo};\n    console.log(sumVec);\n    ctx.beginPath();\n    ctx.translate(v2pxl(sumVec.xo, 'x'), v2pxl(sumVec.yo,'y'));\n    ctx.strokeStyle=\"black\";\n    angle=Math.atan2(sumVec.x, sumVec.y);\n    length=rA*Math.sqrt(sumVec.x**2 + sumVec.y**2);\n    ctx.moveTo(0, 0); ctx.rotate(angle); ctx.lineTo(0, -length); ctx.lineTo(-3, 6-length); ctx.lineTo(0, -length); ctx.lineTo(3, 6-length); ctx.stroke(); ctx.rotate(-angle);\n    ctx.translate(-v2pxl(sumVec.xo, 'x'), -v2pxl(sumVec.yo,'y'));\n  }\n\n\n\n  answers[Qnumber]={figure:\"yes\", prm: vectors};\n}\n\ncnvs.addEventListener('mouseup', onmouseup);\ncnvs.addEventListener('mousedown', onmousedown);\ncnvs.addEventListener('mousemove', onmousemove);\n\ndrawAll();"